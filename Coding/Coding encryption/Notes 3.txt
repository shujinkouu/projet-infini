I am trying to figure out how cryptography works basically different salt generate
different keys even if the password's the same anyway I did a research on the internet
here is the juice:
https://stackoverflow.com/questions/10501247/best-way-to-generate-random-file-names-in-python
https://www.google.com/search?q=find+last+python&oq=find+last+python&aqs=chrome..69i57.2656j0j1&sourceid=chrome&ie=UTF-8
https://stackoverflow.com/questions/213380/the-necessity-of-hiding-the-salt-for-a-hash
https://en.wikipedia.org/wiki/HMAC
https://security.stackexchange.com/questions/3272/password-hashing-add-salt-pepper-or-is-salt-enough
https://www.php.net/manual/en/function.password-hash.php
https://www.google.com/search?q=bcrypt&oq=bcrypt&aqs=chrome..69i57.2660j0j1&sourceid=chrome&ie=UTF-8
https://pypi.org/project/bcrypt/

The conclusion is that we could use bcrypt for our encryption, or at least could be compared to what we have now, pepper seems to be slightly better than salt to hide user
data so we should do that it takes an extra 1/10th of a second but it seems worth it
the pepper can then be saved externally in our app files, pepper.txt or something



C:\Users\Asus\Desktop\Coding encryption\Demo>py
Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:43:08) [MSC v.1926 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import base64
>>> import os
>>> from cryptography.fernet import Fernet
>>> from cryptography.hazmat.primitives import hashes
>>> from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
>>>
>>> password = b'password'
>>> salt = os.urandom(16)
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt
...     iterations=100000
  File "<stdin>", line 5
    iterations=100000
    ^
SyntaxError: invalid syntax
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt
...     iterations=100000,
  File "<stdin>", line 5
    iterations=100000,
    ^
SyntaxError: invalid syntax
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt
...     iterations=100000,
  File "<stdin>", line 5
    iterations=100000,
    ^
SyntaxError: invalid syntax
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt
...     salt=salt
  File "<stdin>", line 5
    salt=salt
    ^
SyntaxError: invalid syntax
>>>
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt,
...     iterations=100000,
... )
>>> key = base64.urlsafe_b64encode(kdf.derive(password))
>>> f = Fernet(key)
>>> token = f.encrypt(b'Secret message!')
>>> token
b'gAAAAABgQDCnjsjRGSZCF1yh4X8QeOD7V7UExSQHYsF8WMCrGSVul_TSbjWJkBkDyEI1lkSUPliqXRx7E7_2gnx3xbsgxjmIEQ=='
>>> f.decrypt(token)
b'Secret message!'
>>> exit()

C:\Users\Asus\Desktop\Coding encryption\Demo>py
Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:43:08) [MSC v.1926 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import base64
>>> import os
>>> from cryptography.fernet import Fernet
>>> from cryptography.hazmat.primitives import hashes
>>> from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
>>>
>>> password = b"password"
>>> salt = os.urandom(16)
>>> kdf = PBKDF2HMAC(
...     algorithm=hashes.SHA256(),
...     length=32,
...     salt=salt,
...     iterations=100000,
... )
>>> key = base64.urlsafe_b64encode(kdf.derive(password))
>>> f = Fernet(key)
>>> f.decrypt(b'gAAAAABgQDCnjsjRGSZCF1yh4X8QeOD7V7UExSQHYsF8WMCrGSVul_TSbjWJkBkDyEI1lkSUPliqXRx7E7_2gnx3xbsgxjmIEQ==')
Traceback (most recent call last):
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\fernet.py", line 119, in _verify_signature
    h.verify(data[-32:])
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\hazmat\primitives\hmac.py", line 74, in verify
    ctx.verify(signature)
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\hazmat\backends\openssl\hmac.py", line 75, in verify
    raise InvalidSignature("Signature did not match digest.")
cryptography.exceptions.InvalidSignature: Signature did not match digest.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\fernet.py", line 80, in decrypt
    return self._decrypt_data(data, timestamp, time_info)
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\fernet.py", line 137, in _decrypt_data
    self._verify_signature(data)
  File "C:\Users\Asus\AppData\Local\Programs\Python\Python38-32\lib\site-packages\cryptography\fernet.py", line 121, in _verify_signature
    raise InvalidToken
cryptography.fernet.InvalidToken
>>>






