Ok so we got 

import cv2

cv2.namedWindow("preview")
vc = cv2.VideoCapture(0)

if vc.isOpened(): # try to get the first frame
    rval, frame = vc.read()
else:
    rval = False

while rval:
    cv2.imshow("preview", frame)
    rval, frame = vc.read()
    key = cv2.waitKey(20)
    if key == 27: # exit on ESC
        break
        cv2.destroyWindow("preview")

//to close it

"""
okay right now I'm learning opencv I'll document what I got here

Chapter 1:
	---
	***This shows an image
	import cv2

	img = cv2.imread("img/lena.jpg")

	cv2.imshow("Output", img)
	cv2.waitKey(0)
	---
	**this shows a video except that the framerate is not respected so it's very fast
	import cv2
	cap = cv2.VideoCapture("img/test_video.mp4")

	while True:
	    success, img = cap.read()
	    cv2.imshow("Video", img)
	    if cv2.waitKey(1) & 0xFF ==ord('q'):
	        break
	---
	***instead on can use the webcam like so
	
	cap = cv2.VideoCapture(0)
	cap.set(3, 640)
	cap.set(4, 480)
	---
	***Brightness
	cap set(10, value) # this designated the brightness
	try value = 100
	---
Chapter 2:
	---
	***This converts the image to gray
	imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
	---
	***This converts the gray or any other image to a blury version
	imgBlur = cv2.GaussianBlur(imgGray,(7,7),0)
	---
	***This converts the gray or any other image to a version with only edge detections
	imgCanny = cv2.Canny(img,100,100)
	---
	***This dilates the edge detection lines, making them thicker, so they are easier to detect
	import numpy as np
	kernel = np.ones((5,5),np.uint8)
	imgDialation = cv2.dilate(imgCanny,kernel,iterations=1)
	#iteration=n (the larger n is the thicker the line will be)
	---
	***This erodes the image making the lines finer
	imgEroded = cv2.erode(imgDialation,kernel,iterations=1)
Chapter 3:
	---example code that can be easily ran---
	"""
	print img(img.shape)
	imgResize  cv2.resize(img, (width, height))
	imgCropped = img[Height, Width]
	imgCropped = img[star:end, star:end]
	"""
	import cv2
	import numpy as np
	
	img = cv2.imread("img/lena.jpg")
	print(img.shape)
	#(835, 800, 3)
	#(Height, Width, Number Of Channels(VGR so 3))

	imgResize = cv2.resize(img,(1,100))
	#imgResize  cv2.resize(img, (width, height))

	imgCropped = img[0:200,200:500]
	#imgCropped = img[Height, Width]
	#imgCropped = img[star:end, star:end]
	
	cv2.imshow("Images", img)
	cv2.imshow("Image Resize", imgResize)
	cv2.imshow("Image Cropped", imgCropped)
	
	cv2.waitKey(0)

	--- Individual Command ---
        print img(img.shape)
	#example output: (835, 800, 3)
	#expressing (Height, Width, Number Of Channels(VGR so 3))
	---
	imgResize  cv2.resize(img, (width, height))
	#Resize the image at selected dimension	
	---
	imgCropped = img[Height, Width]
	imgCropped = img[star:end, star:end]
	#Crops the image making it the new selected dimension 
Chapter 4:
	---example code that can be easily ran---
	import cv2
	import numpy as np

	img = np.zeros((512, 515, 3), np.uint8)
	#print(img)
	#img[:]= 255, 0, 0
	#Changes the whole image to a color one can use img[(start):(end)] just like cropping to create rectangle easily

	cv2.line(img, (0, 0), (img.shape[1], img.shape[0]), (0, 255, 0), 1)
	#cv2.line(imgName, (Start), (END), (Color), Thickness)
	#Start and End are x,y coordinate color is RBG from 256bits

	cv2.rectangle(img, (0, 0), (250, 350), (0, 0, 255), 2)
	#cv2.rectangle(imgName, (Start), (END), (Color), Thickness, cv2.FILLED)
	#cv2.FILLED is optional and fills the shape

	cv2.circle(img, (400, 50), 30, (255, 255, 0), 5)
	#cv2.circle(imgName, (Center), (Radius), (Color), Thickness)

	cv2.putText(img, " OPENCV ", (300, 200), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 150, 0), 3)
	#cv2.putText(imgName, "TextYouWantToDisplay", (Center), cv2.font, FontSize, (Color), Thickness)
Chapter 5:
	---exmple code that can be easily ran---
	import cv2
	import numpy as np

	img = cv2.imread("img/lena.jpg")

	width, height = 250, 350
	#The goal is to outline a rectangle and make it straight use a picture of a card 
	pts1 = np.float32([[111, 219], [287, 188], [154, 482], [352, 440]])
	#[[1stpoint], [2], [3], [4]]
	pts2 = np.float32([[0, 0], [width, 0], [0, height] , [width, height]])
	#Position of said points
	matrix = cv2.getPerspectiveTransform(pts1, pts2)
	imgOutput = cv2.warpPerspective(img, matrix, (width, height))

	cv2.imshow("Image", img)
	cv2.imshow("Output", imgOutput)

	cv2.waitKey(0)
Chapter 6:


cv2.imshow("Image", img)

cv2.waitKey(0)